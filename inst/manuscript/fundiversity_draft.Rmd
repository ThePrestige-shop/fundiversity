---
title: 'fundiversity: a modular R package to compute functional diversity indices'
author:
  - name: Matthias Grenié
    email: matthias.grenie@idiv.de
    orcid_id: 0000-0002-4659-7522
    affiliation: idiv,uleipzig,cefe
    footnote: 1
  - name: Hugo Gruson
    email: hugo.gruson@normalesup.org
    orcid_id: 0000-0002-4094-1476
    affiliation: cefe,london
    footnote: 2

footnote:
  - code: 1
    text: "Corresponding Author"
  - code: 2
    text: "ORCID-ID <0000-0002-4659-7522>; ORCID-ID <0000-0002-4094-1476>"

date: "`r Sys.Date()`"
  
address:
  - code: idiv
    address: |
      German Centre for Integrative Biodiversity Research (iDiv) Halle-Jena-Leipzig,
      Puschstraße 4,
      04103 Leipzig, Germany
  - code: uleipzig
    address: |
      Leipzig University, Ritterstraße 26, 04109 Leipzig, Germany
  - code: cefe
    address: |
      CEFE, 
      Université de Montpellier, CNRS, EPHE, IRD, Université Paul Valéry Montpellier 3, 
      Montpellier, France
  - code: london
    address: |
      Centre for Mathematical Modelling of Infectious Diseases, 
      London School of Hygiene & Tropical Medicine, 
      London, UK

abstract: |
  (max 350 words)
  
  1. Functional diversity is widely used and widespread. However, the main package used to compute functional diversity indices `FD` is not flexible and not adapted to the volume of data used in modern ecological analyses.
  
  2. We here present `fundiversity`, an R package that eases the computation of classical functional diversity indices. It leverages parallelization and memoization (caching results in memory) to maximize efficiency with data with thousands of columns and rows.
  
  3. We also did a performance comparison with packages that provide analog functions. In addition to being more flexible, `fundiversity` was always an order of magnitude quicker than alternatives.
  
  4. `fundiversity` aims to be a lightweight efficient tool to compute functional diversity indices, that can be used in a variety of contexts. Because it has been designed following clear principles, it is easy to extend. We hope the wider community will adopt it and we welcome all contributions.

keywords:
  - biodiversity
  - diversity facet
  - R package
  - functional biogeography
  - functional ecology
  - community ecology


header-includes:
  - \linenumbers
  - \modulolinenumbers
  - \usepackage{endfloat}
  - \hypersetup{citecolor=blue, linkcolor=blue}

csl: methods-in-ecology-and-evolution.csl

bibliography: references.bib

layout: 3p

output: 
  rticles::elsevier_article:
    latex_engine: xelatex
    keep_tex: TRUE
    citation_package: default
  
journal: Ecography
---

Running title (max 45 char.): fundiversity: functional diversity in R

Word count (3000-4000 incl. refs & captions): `r wordcountaddin::word_count()`

# Acknowledgements

Both authors thank Shan Kothari, and two anonymous reviewers for their comments that helped improve the manuscript. MG gratefully acknowledges the support of iDiv funded by the German Research Foundation (DFG--FZT 118, 202548816).

# Authors' Contributions

Our authors' statement follows the Contributor Roles Taxonomy (CRediT, <https://casrai.org/credit/>). **Matthias Grenié**: Conceptualization, Methodology, Software, Resources, Writing - Original Draft, Writing - Review & Editing, Supervision. **Hugo Gruson**: Conceptualization, Methodology, Software, Writing - Review & Editing.

\pagebreak

\resetlinenumber
# Title

fundiversity: a modular R package to compute functional diversity indices

# Introduction

Functional diversity, the diversity of traits across scales, is a major facet of biodiversity [@Pavoine_Measuring_2011]. It has been widely used across ecological contexts [@Cadotte_species_2011] and has been shown to relate to ecosystem functioning [@Diaz_Vive_2001; @Leps_Quantifying_2006]. Many indices exist to characterize it across its three dimensions: richness (how much?), evenness (how regular?), and divergence (how different?) [@Pavoine_Measuring_2011]. Ecologists rely on computational tools to compute these indices in a reproducible fashion, mainly in the R programming language [@Lai_Evaluating_2019; @RCoreTeam_language_2021]. The `FD` package is the main tool available for functional diversity indices, accumulating now over than 1200 citations [@Laliberte_FD_2014]. But `FD` has been released in 2009 receiving only minor updates that stopped in 2015. During this time, software development practices have changed dramatically and new, higher-performance, tools have emerged in the R ecosystem. Additionally, since 2009, the size of ecological datasets has grown exponentially [@Farley_Situating_2018; @Wuest_Macroecology_2020] and high-performance computing (HPC) environments have become standard. There is therefore a dire need for a modern alternative using state-of-the-art software development techniques and tools.

The main function of the `FD` package `dbFD()` lets users compute a dozen functional diversity indices in a single call from raw trait data [@Laliberte_FD_2014]. While great for exploratory analyses, this can increase computation time when only a single index is needed. Furthermore, it does not enforce the good practice of choosing beforehand the appropriate functional diversity index for the question(s) asked [@Legras_Functional_2018; @Mason_guide_2013; @Schleuter_user_2010]. It encourages the user to fish the functional diversity index matching predicted relationships (a form of p-hacking). This can lead users to report all computed functional diversity indices even when there are no clear expectations on different functional diversity facets or to report correlated indices [@Legras_Functional_2018; @Mason_guide_2013; @McPherson_simulation_2018; @Schleuter_user_2010]. Computing all indices in a single function also makes long-term maintenance and addition of new indices harder.

The average size of datasets analyzed in ecology increased several folds in the last years [@Wuest_Macroecology_2020], calling for an increase in performance of computational tools. Especially considering that many diversity analyses use null models that increase the data size by two or three orders of magnitude [@Gotelli_Null_1996]. First, any improvement of the algorithmic efficiency to compute functional diversity indices could save substantial amounts of time as it is repeated many times. For example, we noted that many R packages that compute functional diversity indices do not leverage the specifically optimized matrix algebra packages included in R. Their use can cut the number of operations dramatically compared to using a loop directly in R. Second, functional diversity indices are generally computed over many mathematically independent sites. With the rise of multicore computers, parallelization, i.e. splitting independent computations between different Computing Processor Units (CPUs), is becoming the norm. Very few functional diversity R packages natively implement parallelization, leaving the burden of doing so to the user. There have been tremendous new developments in this area in R over the last few years with the release of the `future` framework [@Bengtsson_unifying_2020] that allows to seamlessly parallelize computations on multiple cores on a single machine, across several machines, or even on a remote cluster without changing execution code. Third, computations on the same input can be cached through a process called memoization [@Wickham_memoise_2021]. This avoids wasting computing power on previously seen inputs. For example, many functional diversity indices rely on the computation of convex hulls across a multi-dimensional space [@Cornwell_TraitBased_2006; @Villeger_New_2008]. Caching the results of this costly computation could save time and computing power when measuring the diversity across similar sets, such as sites across a given region.

Increasing discussions are held regarding scientific software robustness and reliability in ecology [@Mislan_Elevating_2016a; @Poisot_Best_2015; @White_thoughts_2015; @Wilson_Good_2017]. Mainly because most ecologists are self-trained in programming [@Farrell_Power_2018], these virtuous practices are rarely applied in ecology [@Barraquand_Lack_2014]. For example, unit tests use predefined inputs to compare outputs to expectations [@Poisot_Best_2015]. Unit tests have also become standard in R packages since the release of packages streamlining this process, such as `testthat` and `tinytest` [@Wickham_testthat_2011; @derLoo_method_2020]. Very few R functional diversity packages provide unit tests to assess that the functions behave expectedly. Automatic tests of one's code are crucial when developing a tool for a wider audience, as it may be used across different contexts.

Here, we propose a modern alternative to `FD` called `fundiversity` that benefits from modern development practices, necessary features for large-sized datasets (modularity, parallelization, and memoization), and greater flexibility. The package can be easily extended to accommodate additional diversity indices not covered by following a clear design pattern detailed in the next section. We go through a use case to show how it can be used. We then compare the performance of `fundiversity` against similar packages.


# Main features of `fundiversity`

To ensure the consistency of its functions and to make it user-friendly, `fundiversity` follows clear design principles. In this section, we expose its distinctive features and principles.

To give maximum flexibility to the users, we tried to build `fundiversity` as modular as possible. Each function in `fundiversity` computes a single functional diversity index, so that it only returns a single index and nothing more. All functions in `fundiversity` are prefixed with `fd_` to avoid conflict with similarly named functions in other packages, as it is becoming standard practice in R packages [@rOpenSci_rOpenSci_2021]. In line with its modularity, we focused on making the inputs and outputs of functions coherent. The functions use two main inputs: a species by traits matrix and a site by species matrix, all functions accept them as first arguments. Across functions, the outputs are always structured similarly: one `site` column that contains the name of its sites and one column named as the computed index (such as `FRic` when computing functional richness). The shape of the output is predictable and easily combined with other data.

We designed `fundiversity` so it modifies minimally the input data before computing the indices (see Figure \ref{fig1}). When computing functional diversity indices, upstream choices regarding trait standardization and trait space construction are fully part of the scientific question [@Maire_How_2015; @Leps_Quantifying_2006; @deBello_Which_2013; @Mammola_Concepts_2021]. Several packages provide default options that automatically build multivariate spaces, dendrograms, and choose relevant axes of variation. While useful for naive users, these abstract away part of the scientific process that should be considered when using functional diversity indices. These choices have been shown to have strong consequences on the values of downstream indices [@Maire_How_2015; @Leps_Quantifying_2006; @deBello_Which_2013; @Mammola_Concepts_2021]. `fundiversity` chooses to enforce better practices by leaving trait space choices to the user.

Parallelization can vastly decrease computation speed by leveraging the architecture of modern computers. Most functions in `fundiversity` can be parallelized out of the box. `fundiversity` provides parallelization through the `future` backend [@Bengtsson_unifying_2020]. Parallelization is toggled through a single function call using `future::plan()` before using `fundiversity` functions. Thanks to the flexibility given by the `future` backend, the code to use will not change whether parallelizing across several cores on a single computer, across multiple computers, or on a remote high-performance cluster. The user only needs to update the call to `future::plan()`. Furthermore, the `future` backend provides load balancing so that no cores/units stay idle for too long and the parallelized tasks are split evenly. The package contains a dedicated vignette to guide the users through transforming unparallelized to parallelized code (accessible through `vignette("fundiversity_1-parallel", package = "fundiversity")`).

The computation of functional diversity indices often involves null models, which require repeated operations across the same data subsets. This results in computing the same indices over the exact same assemblages over and over. Memoization can leverage the already computed indices and avoid double work. For example, to compute functional richness (FRic) the convex hull of the input data has first to be identified, and then the volume of this convex hull is computed. The first step, identifying the convex hull, takes the most time and as such, storing the results of each computed convex hull can vastly cut computation time for a little memory footprint. If the set of input points is encountered a second time, the results will be taken from memory instead of being recomputed. Memoization trades a little bit of computer memory (keeping the convex hulls stored) for more computation speed. For now, `fundiversity` leverages memoization only for computing convex hulls (as used when computing `FDiv`, `FRic`, and `FRic_intersect`). It is activated by default. This behavior can be overridden by changing the `fundiversity.memoise` option before loading the package.

Packages depend on one another to avoid reinventing the wheel and thus reuse already developed functions. A higher number of dependencies means that a package requires more packages to be installed before its own installation. While having many dependencies minimizes code replication, it also comes with a high price, because if a single dependency breaks then the whole package cannot be installed anymore [@Cox_Surviving_2019]. Inflated dependencies have been identified as a major risk in software and especially scientific software development [@Claes_maintainability_2014; @Cox_Surviving_2019]. `FD` has only four dependencies but other functional diversity packages have many more dependencies (up to 100 dependencies for `hypervolume`, see Table S\ref{tabs1}). This renders them quite brittle for the users after years of not being actively developed. `fundiversity` has been designed to only have minimal external dependencies, it currently depends directly on four, carefully chosen, external packages (details on the criteria of choice in `vignette("fundiversity_4-design-principles", package = "fundiversity")`): `future.apply` which itself depends on two other packages, `Matrix` which is shipped with R, and `geometry` & `vegan` on which `FD` also depends. Considering direct and indirect dependencies, `fundiversity` depends on a total of 21 packages while similar packages depends on 65 packages on average (Table S\ref{tabs1}). 

Because user flexibility is key, `fundiversity` has minimal assumptions on the input data structure. All its functions work with data frames, matrices, or sparse matrices alike. Sparse matrices are a different formalization of matrices that do not store explicitly the cells that contain zero. They offer a reduced memory footprint and optimized algebra library for computation [@Bates_Matrix_2021]. These matrices are thus specifically relevant for occurrence/abundance matrices that contain many zeros. If the used data have a high proportion of zeros, using sparse matrices can vastly decrease computational time in `fundiversity`.

As we underlined in the introduction, automatic software testing, while not 100% flawless, is needed to increase the confidence in the behavior of functions. It is widespread in professional software engineering but much less in scientific software development [@Kanewala_Testing_2014]. This means that software behavior is seldom validated against known inputs to make sure that it behaves in expected ways. It does not mean that the software is of poor quality but rather that some simple errors could introduce unnoticed changes in the behavior of functions. Most packages that compute functional diversity indices do not include any form of automatic testing (3 out of 11 following our assessment). We do want to point out that is the result of the lack of formal training in software development for ecologists hence the lack of tests [@Farrell_Power_2018]. We designed `fundiversity` with many unit tests from the beginning, executing at least every single line of code once (i.e. achieving code coverage of 100%).

`fundiversity` mostly computes alpha functional diversity indices, because other recent packages exist to compute other types of functional diversity indices [Hill numbers, @Li_hillR_2018; beta-diversity indices, @Baselga_betapart_2012]. We focused on indices available through the `dbFD()` function in the `FD` package and on indices that could benefit from faster implementations. The included indices cover the three dimensions of functional diversity: richness (how much total diversity among set?), evenness (how regular are species situated along the trait space?), and divergence (how different are species compared to an average position?) [@Pavoine_Measuring_2011]. `fundiversity` contains the following alpha functional diversity indices: functional richness (FRic), functional dispersion (FDis), functional divergence (FDiv), functional evenness (FEve), and Rao's quadratic entropy (Q). We included Q as we identified the potential for important performance improvements relative to existing packages. `fundiversity` also contains a beta-diversity index as it can be useful to compare functional richness between sites (named FRic_intersect). Thanks to its design, `fundiversity` can be easily extended to include more indices, the included list here is only a snapshot of the available indices in the current version of `fundiversity`.

| Function Name         | Index Name                   | Source                        | Parallelizable | Memoizable |
|:----------------------|:-----------------------------|:------------------------------|:--------------:|:----------:|
| `fd_fdis()`           | Functional Dispersion (FDis) | @Laliberte_distancebased_2010 | Yes            | No         |
| `fd_fdiv()`           | Functional Divergence (FDiv) | @Villeger_New_2008            | Yes            | Yes        |
| `fd_feve()`           | Functional Evenness (FEve)   | @Villeger_New_2008            | Yes            | No         |
| `fd_fric()`           | Functional Richness (FRic)   | @Villeger_New_2008            | Yes            | Yes        |
| `fd_fric_intersect()` | Functional $\beta$-diversity | @Villeger_Decomposing_2013    | Yes            | Yes        |
| `fd_raoq()`           | Rao's Quadratic Entropy (Q)  | @Rao_Diversity_1982           | No             | No         |

Table: List of functions available in `fundiversity` to compute functional diversity indices. The two last columns specify which functions are parallelizable and memoizable.

We made sure the indices were numerically exact by using the test dataset available in Villéger et al. [-@Villeger_New_2008]. The functions in `fundiversity` gave identical results than the one found in Figure 2 of Villéger et al. [-@Villeger_New_2008]. We summarize our comparisons in the numerical correctness vignette accessible through `vignette("fundiversity_3-correctness", package = fundiversity)`. We furthermore compared the obtained results with functions in other packages and made sure to obtain similar values.


# Case Study

In this section, we are showing how to use `fundiversity` in practice. As an example dataset, we included in `fundiversity` site-species and trait data from @Nowak_Data_2019. It is accessible through calls to `site_sp_birds` and `traits_birds` when `fundiversity` is loaded with `library()` or the use of the `data("site_sp_birds", package = "fundiversity")` and `data("traits_birds", package = "fundiversity")` functions when `fundiversity` is not loaded. This dataset describes the presence/absence of bird species in South America at different elevations and four of their morphological traits.

```{r fig1-conceptual-diagram, out.width="100%", fig.align='center', fig.cap="\\label{fig1}Conceptual diagram showing the input and typical ouput data from `fundiversity` functions. Input data are generally a site-species table and a species-traits table, and the output gives back a table of functional diversity index per site.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "fundiversity_conceptual_diagram.svg")
)
```

The trait values show species in rows (species are specified as row names) and traits in columns with trait names as column names (Figure \ref{fig1}). Similarly, the site-species matrix contains sites as rows (site names are row names) and species as columns (species names are column names).

```{r load_data}
data("traits_birds",  package = "fundiversity")
data("site_sp_birds", package = "fundiversity")

head(traits_birds)
head(site_sp_birds)[, 1:3]
```

Now we obtained trait and occurrence data we need to compute the trait dissimilarity between each pair of species. As all traits are quantitative, we first scale them to zero mean and standard deviation of one (z-score), then we compute the Euclidean distance between pairs of species.

```{r trait_dissmilarity}
z_traits = scale(traits_birds, center = TRUE, scale = TRUE)

trait_distance = as.matrix(dist(z_traits))
```

We want to emphasize here that `fundiversity` does not assume anything in the upstream of the computation of functional diversity indices. Trait standardization and computation of a trait dissimilarity are to the user's discretion. They are provided here as a full workflow example. The specific functions used in the previous chunk can vary depending on the scientific question, the nature of the traits, or the transformation needed. `fundiversity` does not provide any functions to deal with these upstream choices as it is the user's responsibility to carefully examine them.

Then, we compute the functional richness at each location using the `fd_fric()` function. It expects quantitative trait values as the first argument and a site-species matrix as the second argument.

```{r fric}
library("fundiversity")

birds_fric = fd_fric(z_traits, site_sp_birds)

head(birds_fric)
```

If the site-species matrix is not provided, `fundiversity` considers that all species present in the trait matrix are all present in a single site:

```{r fric-only-traits}
fd_fric(z_traits)
```

All other functions in `fundiversity` use a similar structure, the first input is trait data, the second one is a site-species matrix (Figure \ref{fig1}). For Rao's quadratic entropy, computed through `fd_raoq()`, functional dissimilarities can be specified as the third argument:

```{r raoq}
# With functional dissimilarity
birds_raoq = fd_raoq(traits = NULL, site_sp_birds, dist_matrix = trait_distance)

# With trait values
birds_raoq_2 = fd_raoq(z_traits, site_sp_birds)

# Both options give the same results
identical(birds_raoq, birds_raoq_2)
```

If not all traits are quantitative, it is possible to transform them back into independent quantitative 'traits' through the use of Gower's distance [@Gower_general_1971; and its extensions: @Podani_Extending_1999; and @Pavoine_challenge_2009] then applying multivariate analysis to obtain orthogonal dimensions [@Maire_How_2015]. But there are many other ways to convert qualitative traits and as such, this is out of the scope of `fundiversity`. We leave it to the user to decide how to proceed to obtain back independent quantitative traits.


## Using parallel computation

As specified above, `fundiversity` allows for parallel computation of functional diversity metrics through the `future` framework. We here demonstrate how to use it in practice with the case study. A more detailed explanation is provided in the "Parallelization" vignette of `fundiversity` (available through `vignette("fundiversity_1-parallel", package = "fundiversity")`).

We first have to check if the function in `fundiversity` is parallelizable: all functions except `fd_raoq()` are. Then we define the parallel setting using the `future::plan()` function. This allows to define how the parallel computation should be split: across cores, across computers, across jobs of a High-Performing Cluster, etc. Here, we split the computation locally across the 4 cores of the computer using the `future::multisession()` function. We specify the number of cores to use with the `workers` argument in the call to the `future::plan()` function.

```{r parallel-example}

# First: Setup a parallel plan
future::plan(future::multisession, workers = 4)

# Second: Perform the computation
bird_fric = fd_fric(traits_birds, site_sp_birds)

head(bird_fric)
```

To use a different backend, you can invoke a different argument in the `future::plan()` function. All possible arguments are detailed in the overview vignette of the `future` package (accessible through `vignette("future-1-overview", package = "future")` once `future` has been installed).

The parallel computations are split across sites, so they may be interesting with large number of sites. However, given the efficiency of `fundiversity` functions, and the overhead costs of parallel computation, we recommend parallelizing only with matrices of at least 10.000 sites, or when hitting a performance limit of the default sequential execution.

Also, parallelization should never be used in conjunction with memoization because of the risk of cache corruption if several cores access the memoized cache simultaneously (make sure to use `options(fundiversity.memoise = FALSE)` before loading `fundiversity` when using parallel computations).


# Performance Comparison

To test the performance improvements realized by `fundiversity`, we compared computation time on standardized datasets across similar functions in other packages. We only compared packages that provide original functions not wrappers that depend on other packages to compute functional diversity indices. Six packages computed similar indices to `fundiversity`. Most indices are also computed by the `FD::dbFD()` function, but the comparison would be unfair as it computes many indices in a single call, while functions in `fundiversity` only compute single indices. We considered functions from: `adiv` [@Pavoine_adiv_2020], `BAT` [@Cardoso_BAT_2015], `betapart` [@Baselga_betapart_2012], `hillR` [@Li_hillR_2018], `mFD` [@Magneville_mFD_2022], and `FD` [@Laliberte_FD_2014] (see Table 2 for the correspondence between packages). A continuously updated version of this section can be found in the performance comparison vignette within the `fundiversity` package with `vignette("fundiversity_2-performance", package = "fundiversity")`.

| Index Name                   | `fundiversity` Functions | Equivalent Functions        |
|:-----------------------------|:-------------------------|-----------------------------|
| Functional Dispersion (FDis) | `fd_fdis()`              | `FD::fdisp()`\linebreak`mFD::alpha.fd.multidim(..., ind_vect = "fdis")` |
| Functional Divergence (FDiv) | `fd_fdiv()`              | `mFD::alpha.fd.multidim(..., ind_vect = "fdiv")`
| Functional Evenness (FEve)   | `fd_feve()`              | `mFD::alpha.fd.multidim(..., ind_vect = "feve")`
| Functional Richness (FRic)   | `fd_fric()`              | `BAT::alpha()` (tree)\linebreak`BAT::hull.alpha()` (hull)\linebreak`mFD::alpha.fd.multidim(..., ind_vect = "fric")` |
| Rao's Quadratic Entropy (Q)  | `fd_raoq()`              | `adiv::QE()`\linebreak`BAT::rao()`\linebreak`hillR::hill_func()`\linebreak`mFD::alpha.fd.hill(..., q = 2, tau = "max")`
| Functional $\beta$-diversity | `fd_fric_intersect()`    | `betapart::functional.beta.pair()`\linebreak`hillR::hill_func_parti_pairwise()`

\label{tab1}Table: List of `fundiversity` functions with corresponding functions in other packages. The name of the package is indicated before the `::` while the name of the functions (including specified arguments) follows.

For testing purposes, we used datasets of increasing size with the number of species being 200, 500, or 1000; the number of traits 2, 4, or 10; and the number of sites 50, 100, or 500. For each set of parameters, we generated a fictional site-species matrix and species-trait matrix, having only continuous traits. We used these simulated data to perform benchmarks across comparable functions (Table \ref{tab1}). The benchmark was run 30 times through the `bench` package [@Hester_bench_2021]. A summary of the results of the benchmark can be seen in Fig. \ref{fig2}. The full results detailing the timings for each combination of parameters and functions are available in the Supplementary Material (Fig. S\ref{figs1}).

```{r fig2-benchmark-results, out.width="100%", fig.align='center', fig.cap="\\label{fig2}Timing comparison across functional diversity indices between packages. Each point represents the execution time of one run using a simulated dataset, the points are transparent and jittered to avoid overplotting. We here show the performance results considering only a single set of parameters with 4 traits, 500 species, and 100 sites, repeated 30 times.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "fig1_sequential_benchmark.png")
)
```

For all the indices and functions tested, `fundiversity` is at least one order of magnitude faster than alternative packages. For functional dispersion (FDis), `fundiversity` is two orders of magnitude faster compared to `BAT` and `mFD`. For functional divergence (FDiv), `fundiversity` is one order of magnitude faster than `mFD`. For functional evenness (FEve), `fundiversity` is two orders of magnitude faster than `mFD` with sequential and parallelized versions having similar performances. For Rao's quadratic entropy (Q), `fundiversity` is one order of magnitude faster than `hillR` and `mFD`, two orders faster than `adiv`, and three orders of magnitude faster than `BAT`. For functional richness (FRic), `fundiversity` is half an order of magnitude faster than the hull version of `BAT`, as well as one and a half order of magnitude faster than its tree version and `mFD`. For functional richness intersection (beta functional diversity), `fundiversity` is two orders of magnitude faster than `betapart` and `hillR`.

```{r fig3-benchmark-parallel, out.width="100%", fig.align='center', fig.cap="\\label{fig3}Timing comparison between parallel and sequential version of fundiversity functions across functional diversity indices. Each point represents the execution time of one run using simulated datasets with fixed properties (4 traits, 100 sites, 500 species), the points are transparent and jittered to avoid overplotting. The parallel version ran across 6 cores.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "fig2_parallel_benchmark.png")
)
```

As shown on Fig. \ref{fig2}, the parallelized versions of `fundiversity` functions executed on average one order of magnitude faster than the sequential versions. For functional richness we even observed a difference of two orders of magnitude. However, for functional dispersion, parallelization increased the overall computation time. This may be due to inherent parallelization issues: there is an overhead cost when splitting tasks across multiple cores of a computer. The efficiency of parallelization depends on the difficulty of the tasks that are split between cores. In the case of functional richness, the main task is computing the convex hull, which is computationally costly, that is why parallelization increases performance in this case. However, computing functional dispersion is simpler, and as such, does not benefit from being split across different cores. Different values for the number of cores, species, traits, or sites produce qualitatively the same results (full results in Fig. S\ref{figs2}).

One important note regarding parallelization in `fundiversity`, is that it is important to avoid doing both memoization and parallelization simultaneously. Memoization creates a cache to avoid recomputing results, and the cache may be corrupted if several cores access the same results at the same time. We noticed that toggling memoization while performing parallelization severely increases total computational time, compared to sequential performance.

Note that these benchmarks only assess the packages computation speed and in no way any package intrinsic quality or usefulness. We are comparing `fundiversity`, a package whose main goal is performance, with other packages that may have other primary goals and offer other benefits. For example, several packages offer nice default visualization functions to plot the different diversity indices, while we explicitly considered that visualization functions were not part of `fundiversity` and let the users decide how they want to plot their indices.


# Conclusion

We proposed a modern alternative R package to compute functional diversity indices. This package follows current best development practices and leverages modern features like parallelization and memoization to increase its performance. This is only made possible by recent developments that were, for the most part, not available at the time when alternative packages came out. `fundiversity` does not propose to replace the entire toolkit for the researcher interested in functional diversity (including the upstream selection of the traits and the building of a functional space), but instead focuses on improving the most computationally costing step: computing functional diversity indices. We hope it will be a useful contribution to this toolkit. To ensure its long-term maintainability, we made the package available on GitHub, it is perennially archived on Zenodo, sits in an independent GitHub organization, and is written following clear design principles. This package aims to always be a work in progress, as such we welcome contributions from interested users and developers.


# Data Availability

`fundiversity` is available on CRAN through `install.packages("fundiversity")` as well as on GitHub at <https://github.com/funecology/fundiversity>, for archival all releases are available on Zenodo at <https://doi.org/10.5281/zenodo.4761754>. The data used in this article are available from the package, through `data(package = "fundiversity")` call.


# Supplementary Information

```{r fig-s1-benchmark-full, out.width="100%", fig.align='center', fig.cap="\\label{figs1}Performance comparison across functions of different packages over a range of parameters (number of traits, species, and sites). Note that each combination of parameters ran 30 iterations. The lines show trends of execution time in function of number of sites of the input dataset.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "s1_external_comparison_full.pdf")
)
```


```{r fig-s2-internal-full, out.width="100%", fig.align='center', fig.cap="\\label{figs2}Performance comparison across internal functions over a range of parameters (number of traits, species, and sites) and different parallelization parameters. Note that each combination of parameters ran 20 iterations. The lines show trends of execution time in function of number of sites of the input dataset.", echo = FALSE}
knitr::include_graphics(
  here::here("inst", "manuscript", "figures", "s2_internal_comparison_full.png")
)
```

```{r table-s1-fd-pkg-deps, echo = FALSE}
fd_deps_df = readRDS(
  here::here("inst", "manuscript", "figures", "tab_s1_pkg_deps.Rds")
)

knitr::kable(
  dplyr::arrange(fd_deps_df, n_hard_deps),
  col.names = c("Package Name", "Number of Hard Dependencies",
                "Number of Total Dependencies"),
  caption = "\\label{tabs1}Table S1. Number of dependencies for functional diversity packages"
)
```

# References
