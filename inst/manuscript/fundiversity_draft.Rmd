---
title: 'fundiversity: a modular R package to compute functional diversity indices'
author:
  - name: Matthias Grenié
    email: matthias.grenie@idiv.de
    orcid_id: 0000-0002-4659-7522
    affiliation: idiv,uleipzig,cefe
    footnote: 1
  - name: Hugo Gruson
    email: hugo.gruson@normalsup.org
    orcid_id: 0000-0002-4094-1476
    affiliation: cefe,london
    footnote: 2

footnote:
  - code: 1
    text: "Corresponding Author"
  - code: 2
    text: "ORCID-ID <0000-0002-4659-7522>; ORCID-ID <0000-0002-4094-1476>"

date: "`r Sys.Date()`"
  
address:
  - code: idiv
    address: |
      German Centre for Integrative Biodiversity Research (iDiv) Halle-Jena-Leipzig,
      Puschstraße 4,
      04103 Leipzig, Germany
  - code: uleipzig
    address: |
      Leipzig University, Ritterstraße 26, 04109 Leipzig, Germany
  - code: cefe
    address: |
      CEFE, 
      Université de Montpellier, CNRS, EPHE, IRD, Université Paul Valéry Montpellier 3, 
      Montpellier, France
  - code: london
    address: |
      Centre for Mathematical Modelling of Infectious Diseases, 
      London School of Hygiene & Tropical Medicine, 
      London, UK

abstract: |
  (max 350 words)
  
  1. Functional diversity is widely used and widespread. However the main package used to compute functional diversity indices `FD` is not flexible and not adapted to the volume of data used in modern ecological analyses;
  
  2. We here present `fundiversity`, an R package that ease the computation of classical functional diversity indices. It is modular, leverages parallelization and memoization (storing some results in memory) to maximize efficiency with data with thousands of columns and rows.;
  
  3. In addition to being more flexible we did a performance comparison with packages that provide analog functions. `fundiversity` was always an order of magnitude quicker than alternative pacakges;
  
  4. `fundiversity` aims to be a lightweight efficient tool to compute functional diversity indices, in order to be used in a variety of context. Because it has been designed following clear principles, it is easy to extend. We hope the wider community will adopt it and we welcome all contributions.

keywords:
  - biodiversity;
  - diversity facet;
  - R package;
  - functional biogeography;
  - functional ecology;
  - community ecology


header-includes:
  - \linenumbers
  - \usepackage{endfloat}

csl: methods-in-ecology-and-evolution.csl

bibliography: references.bib

layout: 3p

output: 
  rticles::elsevier_article:
    latex_engine: xelatex
    keep_tex: FALSE
    citation_package: default
  
journal: Methods in Ecology and Evolution
---

Running title (max 45 char.): fundiversity: functional diversity in R

Word count (3000-4000 incl. refs & captions): `r wordcountaddin::word_count()`

# Introduction

Functional diversity, the diversity of traits across scales, is a major facet of biodiversity [@Pavoine_Measuring_2011]. It has been widely used across ecological contexts [@Cadotte_species_2011] and has been shown to relate to ecosystem functioning [@Diaz_Vive_2001; @Leps_Quantifying_2006]. Many indices exist to characterize it across its three dimensions: richness, evenness, divergence [@Pavoine_Measuring_2011]. To compute these indices in reproducible ways ecologists rely on computational tools able to crunch the numbers for thousands of species and thousands of sites. In the last few years, R has been the programming language of choice for ecologists [@Lai_Evaluating_2019; @RCoreTeam_language_2021]. The main tool available to compute functional diversity indices has been the `FD` package which has now accumulated more than 1200 citations [@Laliberte_FD_2014]. But `FD` has been released in 2009 and has since then only received minor updates that stopped in 2015. At the same time, best practices in software development have changed dramatically and new, more performant tools have emerged in the R ecosystem. Additionally, since 2009, the size of ecological datasets has grown exponentially [@Farley_Situating_2018; @Wuest_Macroecology_2020] and high performance computing (HPC) environments have become standard. There is therefore a dire need for a modern package to compute functional indices using state of the art software development techniques and tools.

The main function of the `FD` package `dbFD()` lets the users compute a dozen functional diversity indices in a single call from raw trait data [@Laliberte_FD_2014]. While great for exploratory analyses this can increase computation time when only a single index is needed. Furthermore, it does not enforce good practice in choosing beforehand the appropriate functional diversity index for the question(s) asked [@Legras_Functional_2018; @Mason_guide_2013; @Schleuter_user_2010]. It encourages the user to fish the functional diversity index that matches their predicted relationships (a form of p-hacking). This can lead the users to report all computed functional diversity indices even when there no clear expectations on different functional diversity facets and/or to report correlated indices [@Legras_Functional_2018; @Mason_guide_2013; @McPherson_simulation_2018; @Schleuter_user_2010]. Building the tool so that indices can be computed independently of one another has the added benefit to make maintenance and addition of new indices easier. Finally, it also improves performance in the case where not all indices are needed.

The average size of datasets analyzed in ecology increased several folds in the last years [@Wuest_Macroecology_2020]. Considering that most analyses on functional diversity rely on null models that increase the data size by two or three orders of magnitude [@Gotelli_Null_1996], the need for efficient computation is paramount. First, any improvement of the algorithmic efficiency to compute functional diversity indices could save sensible amount of time as its repeated many times. For example we noted that many R packages that compute functional diversity indices do not leverage matrix algebra with its libraries available that can cut the number of operations by orders of magnitude. Second, functional diversity indices are generally computed over many mathematically independent sites. With the rise of multi-core computers, parallelization, i.e. splitting independent computations between different Computing Processor Units (CPUs), is becoming the norm. Very few functional diversity R packages propose parallelization which leaves the burden of implementing it to the user. There has been formidable new developments in this area in R over the last few years with the release `future` framework [@Bengtsson_unifying_2020] that allows the user to seamlessly parallelize computations on multiple cores on a single machine, or across several machine, or even on a remote cluster without changing execution code. Third, computations on exact same input can be cached through a process called memoization [@Wickham_memoise_2021]. This avoid wasting computing power on previously seen inputs. Several functional diversity indices rely on the computation of convex hulls across a multi-dimensional space [@Cornwell_TraitBased_2006; @Villeger_New_2008]. Caching the results of this costly computation could save time and computing power when measuring the diversity across similar sets, such as sites across a given region.

Increasing discussions are held regarding scientific software robustness and reliability in ecology [@Mislan_Elevating_2016a; @Poisot_Best_2015; @White_thoughts_2015; @Wilson_Good_2017]. Mainly because most ecologists are self-trained in programming [@Farrell_Power_2018], these virtuous practices are rarely applied in ecology [@Barraquand_Lack_2014]. For example, unit tests use predefined inputs to compare the software's outputs to expectations [@Poisot_Best_2015]. Unit tests have also become standard in R packages since the release of packages streamlining this process, such as `testthat` and `tinytest`. In part because of the relative recentness of the testing frameworks, very few R functional diversity packages provide unit tests to assess that the functions behave in the expected manner. Automatic tests of one's code are crucial when developing a tool for the wider audience as it may be used in many different contexts.

We here propose a modern alternative to `FD` called `fundiversity` that benefits from modern development practices, necessary features for large sized dataset (modularity, parallelization, and memoization), and greater flexibility. The package can be easily extended to accommodate additional diversity indices not covered by following a clear design pattern detailed in the next section. We then go through a use case to show how it can used. We then compare the performance of `fundiversity` against similar packages.

# Main features of `fundiversity`

To ensure the consistency of its functions and to make it user-friendly, `fundiversity` follows clear design principles. In this section, we expose its distinctive features and principles.

To give a maximum flexibility to the users, we tried to make `fundiversity` as modular as possible. Each function in `fundiversity` computes a single functional diversity index, as such if the user is interested in computing a single index, they only need to use a single function. All functions in `fundiversity` are prefixed with `fd_` to avoid conflict with similar named functions in other packages, as it's becoming standard practice in newer R packages [@rOpenSci_rOpenSci_2021]. In line with its modularity, we focused on making the inputs and outputs of functions coherent. The functions compute functional diversity indices using two main information: a species by traits matrix and a site by species matrix, all functions accept these two objects as first arguments. Because the function outputs one diversity value per site the outputs is always structured similarly: one `site` column that contains the name of its site and one column names in function of the computed index (such as `FRic` when computing functional richness). The shape of the output is predictable and easy to be combined with other data.

Parallelization can be an easy way to vastly decrease computation speed why leveraging on the architecture of modern computers. By default almost all functions in `fundiversity` can be parallelized. `fundiversity` provides parallelization through the `future` backend [@Bengtsson_unifying_2020]. Parallelization is toggled through a single function call using `future::plan()` before using fundiversity functions. Thanks to the flexibility given by the future backend, the code to use won't change whether parallelizing across several cores on a single computer, across multiple computers, or on a remote high performance cluster. The user has only to update the call to `future::plan()` to distribute computations on another infrastructure. Furthermore the future backend provides load balancing so that no cores/units stays idle for too long and the parallelized tasks are split evenly. The packages contains a dedicated "Parallelization" vignette to guide the users through transforming unparallelized to parallelized code (accessible through `vignette("parallel", package = "fundiversity")`).

Because functional diversity indices can be computed repeatedly on the same data subset, such as in null models, we can leverage these repeated computations to reuse already computed indices. For example to compute functional richness (FRic) the convex hull of the input data has first to be identified, then the program needs to compute the volume of this convex hull. The first step, identifying the convex hull, takes the most time and as such, storing the results of each computed convex hull across a subset of data can vastly cut computation time for a little memory footprint. Memoization consists in doing exactly that, it trades a little of computer memory (keeping the convex hulls stored) for more computation speed. `fundiversity` leverages memoization for all complex computations such as convex hulls. By default, memoization is turned on for FRic, intersection of convex hulls, and FDiv, however it can sometimes create memory bottleneck which slow down the overall computation. The default behavior can always be overridden through a change in the option `fundiversity.memoise`.

Packages depend on one another to avoid reinventing the wheel and thus reuse already developed functions. A higher number of dependencies means that a package require more packages to be installed prior to its own installation. While a high number of dependencies minimizes code replication, it also comes with high price, because if a single dependency breaks then the whole package cannot be installed anymore [@Cox_Surviving_2019]. Inflated dependencies has been identified as a major risk in software and especially scientific software development [@Claes_maintainability_2014; @Cox_Surviving_2019]. `FD` only has four dependencies but other functional diversity packages have many more dependencies. This render them quite brittle for the users after years of not being actively developed. `fundiversity` has been designed to only have minimal external dependencies, it currently depends on only four external packages: `future.apply` which depends only on two other packages, `Matrix` which is shipped with R, `geometry` and `vegan` on which `FD` also depends.

Because user flexibility is key, `fundiversity` has minimal assumptions on the input data structure. All its functions work with data frames, matrices or sparse matrices alike. Sparse matrices are a different formalization of matrix that do not store explicitly the cells that contain zero. They offer a reduced memory footprint and optimized algebra library for computation [@Bates_Matrix_2021]. These matrices are thus specifically relevant for occurrence/abundance matrices that contain many zeros. If the used data have a high proportion of zeros, using sparse matrices can vastly decrease computational time in `fundiversity`.

As we underlined in introduction, automatic software testing, while not 100% foolproof, is needed to increase the confidence in the behavior of functions. It is widespread in computer science but less in scientific software development. This means that software behavior is never assessed against known inputs to make sure it behaves in expected ways. It does not mean that the software is of poor quality, but rather that some simple errors could introduce unnoticed changes in the behavior of functions. Most packages that compute functional diversity indices do not include any form of automatic testing. We do want to point out that most ecologists never received formal training in software development hence the lack of tests [@Farrell_Power_2018]. We designed `fundiversity` with many unit tests from the beginning, executing at least every single line of code once (i.e. achieving a coverage of 100%).

`fundiversity` only computes alpha functional diversity indices, because other packages exist to compute other types of functional diversity indices [Hill numbers, @Li_hillR_2018; beta-diversity indices, Baselga_betapart_2012]. We focused on indices available through the `dbFD()` function in the `FD` package and on indices that could benefit from faster implementation. fundiversity contains the following alpha functional diversity indices: functional richness (FRic), functional dispersion (FDis), functional divergence (FDiv), functional evenness (FEVE), and Rao's quadratic entropy (Q). `fundiversity` also contains a beta-diversity index as it can be useful to compare functional richness between sites.

| Function Name         | Index Name                   | Source                        | Parallelizable | Memoizable |
|:----------------------|:-----------------------------|:------------------------------|:--------------:|:----------:|
| `fd_fdis()`           | Functional Dispersion (FDis) | @Laliberte_distancebased_2010 | Yes            | No         |
| `fd_fdiv()`           | Functional Divergence (FDiv) | @Villeger_New_2008            | Yes            | Yes        |
| `fd_feve()`           | Functional Evenness (FEve)   | @Villeger_New_2008            | Yes            | No         |
| `fd_fric()`           | Functional Richness (FRic)   | @Villeger_New_2008            | Yes            | Yes        |
| `fd_fric_intersect()` | Functional $\beta$-diversity | @Villeger_Decomposing_2013    | Yes            | Yes        |
| `fd_raoq()`           | Rao's Quadratic Entropy (Q)  | @Rao_Diversity_1982           | No             | No         |

Table: List of function available in `fundiversity` to compute functional diversity indices. The two last columns specify which functions are parallelizable and memoizable.

# Case Study

Now that we described the main features of fundiversity, we are going to show how to use in practice when computing functional diversity indices. As an example dataset we included in `fundiversity` site-species and trait data from @Nowak_Data_2019. It is accessible through the use of the `data(..., package = "fundiversity")` function. This dataset describes the presence of bird species in South America at different elevations and four morphological traits.

The trait values show species in rows (species are specified as row names) and traits in columns with trait names as columns names. Similarly site-species matrix contains sites as rows (site names are row names) and species as columns (species names are column names).

```{r load_data}
data("traits_birds",  package = "fundiversity")
data("site_sp_birds", package = "fundiversity")

head(traits_birds)
head(site_sp_birds)[, 1:3]
```

Now we obtained trait and occurrence data we need to compute the trait dissimilarity between each pair of species. As all traits are quantitative we first Z-score them, then we compute the Euclidean distance between pair of species.

```{r trait_dissmilarity}
z_traits = scale(traits_birds, center = TRUE, scale = TRUE)

trait_distance = as.matrix(dist(z_traits))
```

We can then compute the functional richness of each indices at each location. To do so we are using the `fd_fric()` function. It expects quantitative trait values as first argument and a site-species matrix as a second argument.

```{r fric}
library("fundiversity")

birds_fric = fd_fric(z_traits, site_sp_birds)

head(birds_fric)
```

All other functions in `fundiversity` use a similar structure, the first input is trait data the second one is a site-species matrix. For Rao's quadratic entropy computed through `fd_raoq()` functional dissimilarities can be specified as the third argument:

```{r raoq}
# With functional dissimilarity
birds_raoq = fd_raoq(traits = NULL, site_sp_birds, dist_matrix = trait_distance)

# With trait values
birds_raoq_2 = fd_raoq(z_traits, site_sp_birds)

# Both options give the same results
identical(birds_raoq, birds_raoq_2)
```

If all traits are not quantitative it is possible to transform them back into independent traits through the use of Gower's distance [@Gower_general_1971; and its extensions: @Podani_Extending_1999, @Pavoine_challenge_2009;] then applying a multivariate analysis to obtain orthogonal dimensions [@Maire_How_2015].


# Performance Comparison

In order to test the actual performance improvements realised by `fundiversity`, we compared computation time on standardized datasets across similar functions in other packages. We only compared to "original" packages that provide actual functions and not wrappers that depends on other packages to provide computation of functional diversity indices. We identified a total of 11 similar packages of which 6 computed similar indices to `fundiversity`. Most indices are included `FD::dbFD()` function but the comparison would be unfair as the function computes many indices in a single call while functions in `fundiversity` only compute single indices. We considered functions from: `adiv` [@Pavoine_adiv_2020], `BAT` [@Cardoso_BAT_2015], `betapart` [@Baselga_betapart_2012], `hillR` [@Li_hillR_2018], `mFD` [@Magneville_mFD_2022], and `FD` [@Laliberte_FD_2014] (see Table 2 for the correspondance between packages). An continuously updated version of this section can be found in the performance comparison vignette within the `fundiversity` package with `vignette("performance", package = "fundiversity")`.

| Index Name                   | `fundiversity` Functions | Functions in other packages |
|:-----------------------------|:-------------------------|-----------------------------|
| Functional Dispersion (FDis) | `fd_fdis()`              | `BAT::dispersion()`\linebreak`FD::fdisp()`\linebreak`mFD::alpha.fd.multidim(..., ind_vect = "fdis")` |
| Functional Divergence (FDiv) | `fd_fdiv()`              | `mFD::alpha.fd.multidim(..., ind_vect = "fdiv")`
| Functional Evenness (FEve)   | `fd_feve()`              | `mFD::alpha.fd.multidim(..., ind_vect = "feve")`
| Functional Richness (FRic)   | `fd_fric()`              | `BAT::alpha()` (tree)\linebreak`BAT::hull.alpha()` (hull)\linebreak`mFD::alpha.fd.multidim(..., ind_vect = "fric")` |
| Rao's Quadratic Entropy (Q)  | `fd_raoq()`              | `adiv::QE()`\linebreak`BAT::rao()`\linebreak`hillR::hill_func()`\linebreak`mFD::alpha.fd.hill(..., q = 2, tau = "max")`
| Functional $\beta$-diversity | `fd_fric_intersect()`    | `betapart::functional.beta.pair()`\linebreak`hillR::hill_func_parti_pairwise()`

Table: List of function available in `fundiversity` to compute functional diversity indices and corresponding functions in other packages. The name of the package is indicated before the `::` while the name of the functions (including specified arguments) follow.

For testing purposes, we used datasets of increasing size with the number of species being 200, 500 or 1000; the number of trait 2, 4, or 10; the number of sites 50, 100, or 500. For each set of parameters, we generated a fictional site-species matrix and site-trait matrix, comprised only of continuous trait data. We used these simulated data to perform benchmarks across comparable functions among the selected packages. The benchmark ran 30 times through the `bench` package [@Hester_bench_2021]. A summary of the results of the benchmark can be seen in Fig. \ref{fig1}. Full results detailing the timings for each combination of parameters and functions are available in the Supplementary Material.

```{r fig1-benchmark-results, fig.width = 7, fig.height=8, fig.align='center', fig.cap="\\label{fig1}Timing comparison across functional diversity indices between packages. Each point represents the execution time of one run using a simulated dataset, the points are transparent and jittered to avoid overplotting. We here show the performance results considering only a single set of parameters with 4 traits, 500 species, and 100 sites, repreated 30 times.", echo = FALSE, message = FALSE}
library("dplyr")
library("ggtext")
library("patchwork")
library("ggbeeswarm")
library("bench")

readRDS(here::here("inst", "fig1_simplified_benchmark.Rds"))
```

We see that for all the indices and function tested, `fundiversity` is at least an order of magnitude faster than alternative packages. For functional dispersion, `fundiversity` is two order of magnitudes faster compared to `BAT` and `mFD`. For functional divergence, `fundiversity` is one order of magnitude faster than `mFD`. For functional evenness, `fundiversity` is two orders of magnitude faster than `mFD` with sequential and parallelized versions having similar performances. For Rao's quadratic entropy, b`fundiversity` is one order of magnitude faster than `hillR` and `mFD`, two orders faster than `adiv`, and three orders of magnitude faster than `BAT`. For functional richness, `fundiversity` is half an order of magnitude faster than the hull version of `BAT`, as well as one and a half order of magnitude faster than its tree version and `mFD`. For functional richness intersection (beta functional diversity), `fundiversity` is two orders of magnitude faster than `betapart` and `hillR`.

<!-- Insert fig parallelized vs sequential -->

The parallelized versions of `fundiversity` functions do not always perform better than the sequential versions. This may be due to inherent parallelization issues: there is an overhead cost when splitting tasks across multiple cores of a computer. The efficiency of parallelization depends on the total number of tasks split as well as the number of cores over which the parallelization is done. Overall, our testing framework was slightly biased towards sequential processing as we were limited in the testing dataset size, since each computation is run multiple to create a reliable benchmark. Nonetheless, we recommend parallel options to be carefully assessed in function of the size of the dataset and the number of available cores. We found (in the supplementary material) that parallelized functions were more efficient with much bigger datasets.

# Conclusion

We proposed a modern alternative R package to compute functional diversity indices. This package follows current best development practices and leverages modern features like parallelization and memoization to increase its performance. This is only made possible by recent developments which were for the most part not available at the time when competing packages came out. `fundiversity` does not propose to replace the entire toolkit for the researcher interested in functional diversity (including upstream selection of the traits and building of a functional space) but instead focuses on improving the most computationally costing step: computing functional diversity indices. We hope it will be a useful contribution in this toolkit. This package aims to always be a work in progress and we welcome contributions from interested users and developers.

# Acknowledgements

MG gratefully acknowledges the support of iDiv funded by the German Research Foundation (DFG--FZT 118, 202548816).

# Authors' Contributions

Our authors' statement follows the Contributor Roles Taxonomy (CRediT, <https://casrai.org/credit/>). **Matthias Grenié**: Conceptualization, Methodology, Software, Resources, Writing - Original Draft, Writing - Review & Editing, Supervision. **Hugo Gruson**: Conceptualization, Methodology, Software, Writing - Review & Editing.

# Data Availability

`fundiversity` is available on CRAN through `install.packages("fundiversity")` as well as on GitHub at <https://github.com/Bisaloo/fundiversity>, for archival all releases are available on Zenodo at <https://doi.org/10.5281/zenodo.4761754>. The data used in this article are available from the package, through `data(package = "fundiversity")` call.

# References
